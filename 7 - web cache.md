🔐 نمایش و توضیح: کشف یک آسیب‌پذیری ساده Web Cache Deception که درآمدزا بود 💰💰

مشکلات Web Cache Deception ممکنه پیچیده به نظر برسن، اما با رویکرد درست، ساده‌ان و می‌تونن منجر به پاداش‌های خوبی بشن، از ۱۰۰۰ تا ۱۰,۰۰۰ دلار، بسته به میزان تاثیر.

امروز می‌خوام تجربه‌ام رو از کشف یک مورد ساده Web Cache Deception به اشتراک بذارم که باعث شد بتونم به داده‌های PII کاربران از طریق کش شدن دسترسی پیدا کنم و در نتیجه پاداش «بالا» دریافت کنم.

رویکرد قدم به قدم من:

1️⃣ دعوت به یک برنامه خصوصی - اولین حرکتم بررسی هدرهای Request/Response برای پیدا کردن پیکربندی‌های اشتباه رایج بود. فوراً هدرهای معمول کش مثل Server-Timing، CF-Cache-Status، X-Cache، X-CDN و... رو دیدم.

2️⃣ شناسایی هدرهای کش جالب - وقتی این هدرها رو مشخص کردم، گام بعدی تحلیل رفتار اپلیکیشن بود. آدرس‌های نمونه رو به Repeater فرستادم و مسیرهای گمراه‌کننده‌ای به URIها اضافه کردم. مثلاً اگر مسیر https://target(.)com/api/v1/users داده‌های حساس PII برمی‌گردوند، تست‌هایی مثل https://target(.)com/api/v1/users/self.css یا https://target(.)com/api/v1/users/self/.js رو امتحان کردم تا ببینم آیا پاسخ کش‌شدنی هست یا نه.

3️⃣ یک مشکل کش ساده - در مورد من، مشکل کش خیلی ساده بود چون endpointها با پسوند اضافه‌شده، پاسخ HTTP 200 و HIT از کش می‌دادن :) سناریوی حمله شامل ساختن یک لینک مخرب مثل https://target(.)com/api/v1/users/self/.js?cachebuster و ارسال اون به قربانی بود. وقتی قربانی که قبلاً لاگین کرده بود، لینک رو باز می‌کرد، اطلاعات PII اون به خاطر پیکربندی اشتباه کش می‌شد.

4️⃣ سوء‌استفاده از کش - وقتی به عنوان مهاجم با حالت ناشناس کروم (Incognito) به آدرس https://target(.)com/api/v1/users/self/.js?cachebuster می‌رفتم، پاسخ کش‌شده حاوی داده‌های PII قربانی از مسیر /api/v1/users/self/ بود که باعث افشای اطلاعات حساس می‌شد.

هرچند این یه سناریوی نسبتاً ساده بود، اما با تکنیک‌های پیچیده‌تر مثل زنجیره کردن CSRF، XSS و غیره، میشه این نوع مشکلات رو به ATO تبدیل کرد که نیاز به کاوش پارامتر و/یا دور زدن محدودیت‌ها داره. در توییت‌های بعدی به این موارد هم می‌پردازیم!

نکته پایانی: همیشه حواست به هدرهای کش‌شدنی باشه و مطمئن شو این نوع آسیب‌پذیری توی چک‌لیستت هست.
